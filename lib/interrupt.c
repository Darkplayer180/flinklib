/*******************************************************************************************
 *    ____   _____ _______            _________  _____     _____  ____  _____  ___  ____   *
 *   / __ \ / ____|__   __|          |_   ___  ||_   _|   |_   _||_   \|_   _||_  ||_  _|  *
 *  | |  | | (___    | |    _______    | |_  \_|  | |       | |    |   \ | |    | |_/ /    *
 *  | |  | |\___ \   | |   |_______|   |  _|      | |   _   | |    | |\ \| |    |  __'.    *
 *  | |__| |____) |  | |              _| |_      _| |__/ | _| |_  _| |_\   |_  _| |  \ \_  *
 *   \____/|_____/   |_|             |_____|    |________||_____||_____|\____||____||____| *
 *                                                                                         *
 *******************************************************************************************
 *                                                                                         *
 *            flink userspace library, Subdevice function "Interrupt multiplexer"          *
 * 									   and IRQ register function to kernel                 *
 *                                                                                         *
 *******************************************************************************************/
 
/** @file reflexSensoren.c
 *  @brief flink userspace library, Subdevice function "Interrupt multiplexer" and IRQ register function to kernel.
 *
 *  Contains the high-level functions for interrupt functionality
 *
 *  @author Patrick Good
 */

#include "flinklib.h"
#include "flinkioctl.h"
#include "types.h"
#include "error.h"
#include "log.h"

#include <stdint.h>

/**
 * @brief Registers a irq handler
 * @param dev: Flink device.
 * @param irq_number: Contains the requested irq number
 * @return int: >=0 on success(Signal Nr), -1 in case of failure.
 */
int flink_register_irq(flink_dev *dev, uint32_t irq_number){
	ssize_t read_size = 0;
	ioctl_container_t ioctl_arg;
	ioctl_arg.subdevice = 0;
	ioctl_arg.offset    = 0;
	ioctl_arg.size      = 4;
	ioctl_arg.data      = &irq_number;

	// read data from device
	read_size = flink_ioctl(dev, REGISTER_IRQ, &ioctl_arg);
	if(read_size < 0) {
		libc_error();
		return EXIT_ERROR;
	}
	
	return read_size;
}

/**
 * @brief Registers a irq handler
 * @param dev: Flink device.
 * @param irq_number: Contains the requested irq number
 * @return int: 0 on success, -1 in case of failure.
 */
int flink_unregister_irq(flink_dev *dev, uint32_t irq_number){
	ssize_t read_size = 0;
	ioctl_container_t ioctl_arg;
	ioctl_arg.subdevice = 0;
	ioctl_arg.offset    = 0;
	ioctl_arg.size      = 4;
	ioctl_arg.data      = &irq_number;

	// read data from device
	read_size = flink_ioctl(dev, UNREGISTER_IRQ, &ioctl_arg);
	if(read_size < 0) {
		libc_error();
		return EXIT_ERROR;
	}
	
	return EXIT_SUCCESS;
}

/**
 * @brief get the signal offset
 * @param dev: Flink device.
 * @param offset: Pointer to a buffer where the offset is written to.
 * @return int: 0 on success, -1 in case of failure.
 */
int flink_get_signal_offset(flink_dev *dev, uint32_t *offset){
	ssize_t read_size = 0;
	ioctl_container_t ioctl_arg;
	ioctl_arg.subdevice = 0;
	ioctl_arg.offset    = 0;
	ioctl_arg.size      = REGISTER_WITH;
	ioctl_arg.data      = offset;

	// read data from device
	read_size = flink_ioctl(dev, GET_SIGNAL_OFFSET, &ioctl_arg);
	if(read_size < 0) {
		libc_error();
		return EXIT_ERROR;
	}
	
	return EXIT_SUCCESS;
}

/**
 * @brief Route an IRQ generated by a flink subdev through the multiplexer of a specific IRQ.
 * @param subdev: Flink subdevice.
 * @param irq: Destination IRQ. This irq number is the requested one in the application
 * @param flink_irq: Source IRQ. This IRQ comes from a flink subdevice.
 * @return int: 0 on success, -1 in case of failure.
 */
int flink_set_irq_multiplex(flink_subdev *subdev, uint32_t irq, uint32_t flink_irq) {
	uint32_t offset = 0;

	offset = HEADER_SIZE + SUBHEADER_SIZE + REGISTER_WITH*irq;
	dbg_print("  --> calculated offset is 0x%x!\n", offset);

	if(flink_write(subdev, offset, REGISTER_WITH, &flink_irq) != REGISTER_WITH) {
		libc_error();
		return EXIT_ERROR;
	}

	return EXIT_SUCCESS;
}

/**
 * @brief Route an IRQ generated by a flink subdev through the multiplexer of a specific IRQ.
 * @param subdev: Flink subdevice.
 * @param irq: Destination IRQ. This irq number is the requested one in the application
 * @param flink_irq: Source IRQ. This IRQ comes from a flink subdevice.
 * @return int: 0 on success, -1 in case of failure.
 */
int flink_get_irq_multiplex(flink_subdev *subdev, uint32_t irq, uint32_t *flink_irq) {
    uint32_t offset = 0;

	offset = HEADER_SIZE + SUBHEADER_SIZE + REGISTER_WITH*irq;
	dbg_print("  --> calculated offset is 0x%x!\n", offset);
	
	if(flink_read(subdev, offset, REGISTER_WITH, flink_irq) != REGISTER_WITH) {
		libc_error();
		return EXIT_ERROR;
	}
	return EXIT_SUCCESS;
}
